



In [ ]:



'''0. Pandas has full-featured, high performance in-memory join operations idiomatically very similar 
to relational databases like SQL.

Pandas provides a single function, merge, as the entry point for all standard database
join operations between DataFrame objects −

*****The generic Syntax for merge in Pandas*****;

pd.merge(left, right, how='inner', on=None, left_on=None, right_on=None,left_index=False, right_index=False, sort=True)


Here, we have used the following parameters −

left − A DataFrame object.

right − Another DataFrame object.

on − Columns (names) to join on. Must be found in both the left and right DataFrame objects.

left_on − Columns from the left DataFrame to use as keys. Can either be column names or arrays with length equal to the length of the DataFrame.

right_on − Columns from the right DataFrame to use as keys. Can either be column names or arrays with length equal to the length of the DataFrame.

left_index − If True, use the index (row labels) from the left DataFrame as its join key(s). In case of a DataFrame with a MultiIndex (hierarchical), the number of levels must match the number of join keys from the right DataFrame.

right_index − Same usage as left_index for the right DataFrame.

how − One of 'left', 'right', 'outer', 'inner'. Defaults to inner. Each method has been described below.

sort − Sort the result DataFrame by the join keys in lexicographical order. Defaults to True, setting to False will improve the performance substantially in many cases.

Let us now create two different DataFrames and perform the merging operations on it.

**********;'''




In [ ]:



'''1. Do we need sorting of the primary key in pandas? The Sorting is not required in pandas
The output is driven by the first frame, the key type should be same
'''
import pandas as pd
a = pd.DataFrame({
         'id':[3,1,2],
         'Name': ['a', 'b', 'c'],
         'sub':['M','E','S']})
b = pd.DataFrame(
         {'id':[1,2,13],
         'marks':[100,52,99]})
c=pd.merge(a,b,how='inner',on='id')
c




In [ ]:



'''1.1 Do we need sorting of the primary key in pandas? The Sorting is not required in pandas
The output is driven by the first frame
'''
import pandas as pd
a = pd.DataFrame({
         'id':[3,1,2],
         'Name': ['a', 'b', 'c'],
         'sub':['M','E','S']})
b = pd.DataFrame(
         {'id':[1,2,13],
         'marks':[100,52,99]})
c=pd.merge(a,b,how='inner',on='id')
c




In [ ]:



'''2.
Primary key is definitely required, however the mention is not required if there are common keys, 
similar to Natural join in SAS and default is inner join
'''
import pandas as pd
a = pd.DataFrame({
         'id':[3,1,21],
         'Name': ['a', 'b', 'c'],
         'sub':['M','E','S']})
b = pd.DataFrame(
         {'id':[1,2,3],
         'marks':[100,52,99]})
c=pd.merge(b,a)
c




In [ ]:



'''2.1 Let's take another example, where 2 keys are common, both are used for the merge'''
import pandas as pd
a = pd.DataFrame({
         'id':[1,21,3],
         'Name': ['a', 'b', 'c'],
         'sub':['M','E','S']})
b = pd.DataFrame(
         {'id':[1,2,3],
          'Name': ['a', 'b', 'k'],
         'marks':[100,52,99]})
c=pd.merge(b,a)
c




In [ ]:



'''3. What if there is no common key, the code would error out '''
import pandas as pd
a = pd.DataFrame({
         'id1':[1,2,3],
         'Na': ['a', 'b', 'c'],
         'sub':['M','E','S']})
b = pd.DataFrame(
         {'id':[1,2,3],
          'Name': ['a', 'b', 'k'],
         'marks':[100,52,99]})
c=pd.merge(b,a)
c




In [ ]:



'''4. How can I merge based on 2 keys or composite key'''
import pandas as pd
a = pd.DataFrame({
         'id':[1,2,3],
         'Name': ['a', 'b', 'c'],
         'sub':['M','E','S']})
b = pd.DataFrame(
         {'id':[1,2,7],
          'Name': ['a', 'baba', 'k'],
         'marks':[100,52,99]})
c=pd.merge(b,a, how='inner',on=['id','Name'])
c




In [ ]:



'''5. what if the key vars have diff names in the 2 dataframes'''

import pandas as pd
a = pd.DataFrame({
         'id':[3,1,7],
         'Name': ['a', 'b', 'c'],
         'sub':['M','E','S']})
b = pd.DataFrame(
         {'pid':[1,2,3],
         'marks':[100,52,99]})
c=pd.merge(a,b,how='inner',left_on=['id'], right_on=['pid'])
c




In [ ]:



'''6. Loyal Customers: The Loyal customers can be identified using the inner join of the 2 frames
The Indicator helps
'''
import pandas as pd
jan = pd.DataFrame({'id':[1,2,3]})
feb = pd.DataFrame({'id':[1,2,7]})
check=pd.merge(jan,feb, how='outer',on='id',indicator=True)
loyal=check[(check._merge=='both')]
loyal.drop(['_merge'],axis=1)




In [ ]:



'''7. Left Customers: The customers can be identified in the same way
'''
import pandas as pd
jan = pd.DataFrame({'id':[1,2,3]})
feb = pd.DataFrame({'id':[1,2,7]})
check=pd.merge(jan,feb, how='outer',on='id',indicator=True)
left=check[(check._merge=='left_only')]
left.drop(['_merge'],axis=1)




In [ ]:



'''8. New Customers: The Loyal customers can be identified
'''
import pandas as pd
jan = pd.DataFrame({'id':[1,2,3]})
feb = pd.DataFrame({'id':[1,2,7]})
check=pd.merge(jan,feb, how='outer',on='id',indicator=True)
new=check[(check._merge=='right_only')]
new.drop(['_merge'],axis=1)

